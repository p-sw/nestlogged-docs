/*@jsxRuntime automatic*/
/*@jsxImportSource react*/
export const tableOfContents = [{
  "depth": 1,
  "value": "NestLogged에 대하여",
  "id": "nestlogged에-대하여"
}, {
  "depth": 1,
  "value": "NestLogged 로거 적용",
  "id": "nestlogged-로거-적용"
}, {
  "depth": 1,
  "value": "메서드에 로그 붙이기",
  "id": "메서드에-로그-붙이기",
  "children": [{
    "depth": 2,
    "value": "데코레이터 옵션",
    "id": "데코레이터-옵션"
  }, {
    "depth": 2,
    "value": "전체 메서드 일괄 로깅",
    "id": "전체-메서드-일괄-로깅"
  }]
}, {
  "depth": 1,
  "value": "호출 파라미터 로그",
  "id": "호출-파라미터-로그",
  "children": [{
    "depth": 2,
    "value": "데코레이터 파라미터",
    "id": "데코레이터-파라미터",
    "children": [{
      "depth": 3,
      "value": "name (필수)",
      "id": "name-필수"
    }, {
      "depth": 3,
      "value": "Options (선택)",
      "id": "options-선택"
    }]
  }, {
    "depth": 2,
    "value": "Each 사용법",
    "id": "each-사용법"
  }]
}, {
  "depth": 1,
  "value": "종료 반환값 로그",
  "id": "종료-반환값-로그"
}, {
  "depth": 1,
  "value": "기타 특수함수 로그",
  "id": "기타-특수함수-로그"
}, {
  "depth": 1,
  "value": "로그 주입과 범위 로깅",
  "id": "로그-주입과-범위-로깅"
}, {
  "depth": 1,
  "value": "추가: Pino 적용하기",
  "id": "추가-pino-적용하기"
}];
function _createMdxContent(props) {
  const _components = {
    a: "a",
    blockquote: "blockquote",
    code: "code",
    div: "div",
    h1: "h1",
    h2: "h2",
    h3: "h3",
    hr: "hr",
    li: "li",
    p: "p",
    pre: "pre",
    strong: "strong",
    ul: "ul",
    ...props.components
  };
  return <><_components.p>{"이 문서에서는 NestLogged에 대해 아무것도 모른다는 전제 하에 처음부터 끝까지 NestLogged의 모든 "}<_components.strong>{"기능 사용법"}</_components.strong>{"을 설명합니다."}</_components.p>{"\n"}<_components.p>{"NestLogged를 처음 접하는 분에게 추천합니다."}</_components.p>{"\n"}<_components.h1 id="nestlogged에-대하여">{"NestLogged에 대하여"}</_components.h1>{"\n"}<_components.p>{"NestLogged는 NestJS를 위한 간단한 데코레이터를 제공하며, 여러 복잡한 로깅을 간단하게 적용할 수 있도록 도와줍니다."}</_components.p>{"\n"}<_components.p>{"NestLogged가 제공하는 기능은 다음과 같습니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li>{"함수의 호출과 종료, 오류 로그 ("}<_components.strong>{"NestLogged의 핵심이자 기반입니다!"}</_components.strong>{")"}</_components.li>{"\n"}<_components.li>{"함수의 호출 시 파라미터 로그"}{"\n"}<_components.ul>{"\n"}<_components.li>{"파라미터가 object 또는 array일 경우 일부 프로퍼티의 숨김 또는 선택 지원"}</_components.li>{"\n"}</_components.ul>{"\n"}</_components.li>{"\n"}<_components.li>{"함수의 종료 시 반환값 로그"}</_components.li>{"\n"}<_components.li>{"함수의 호출 흐름을 따라 trace log 표시 (Scope라고 부릅니다)"}</_components.li>{"\n"}<_components.li>{"고유한 Request에 대한 ID 표시"}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.p>{"예시 로그 출력을 보여드리겠습니다:"}</_components.p>{"\n"}<_components.pre><_components.code className="language-log" data-language="log">{"LOG [AppMiddleware] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppMiddleware.AppMiddleware: HIT MIDDLEWARE AppMiddleware.AppMiddleware (/)\nLOG [AppMiddleware] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppMiddleware.AppMiddleware: Hello from Middleware!\nLOG [AppGuard] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppGuard.AppGuard: HIT GUARD AppGuard.AppGuard (/)\nLOG [AppGuard] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppGuard.AppGuard: Hello from Guard!\nLOG [AppGuard] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppGuard.AppGuard: RETURNED GUARD AppGuard.AppGuard (/)\nLOG [AppMiddleware] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppMiddleware.AppMiddleware: RETURNED MIDDLEWARE AppMiddleware.AppMiddleware (/)\nLOG [AppController] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello: HIT ENDPOINT AppController.getHello (AppController::/[GET])\nLOG [AppService] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello -> AppService.getHello: HIT FUNCTION AppService.getHello WITH value=i\nLOG [AppService] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello -> AppService.getHello: Hello from AppService!\nLOG [AppService] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello -> AppService.getHello: RETURNED FUNCTION AppService.getHello\nLOG [AppController] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello: RETURNED ENDPOINT AppController.getHello (AppController::/[GET]) WITH i\n"}</_components.code></_components.pre>{"\n"}<_components.p>{"재미있는 점은 이 로그들이 간단한 데코레이터 몇 개로 이루어질 수 있는 것이라는 점입니다.\n지금부터 하나씩 어떻게 하는지 알려드리겠습니다."}</_components.p>{"\n"}<_components.hr />{"\n"}<_components.h1 id="nestlogged-로거-적용">{"NestLogged 로거 적용"}</_components.h1>{"\n"}<_components.p>{"NestLogged에서는 내부에서 처리되는 로그 객체에 Request ID와 Scope를 추가합니다."}</_components.p>{"\n"}<_components.p>{"그러나 NestJS에서 기본으로 적용되어 있는 ConsoleLogger는 추가된 Request ID와 Scope를 제대로 포맷하지 않고 출력하기 때문에 새로운 ConsoleLogger의 적용이 필요합니다."}</_components.p>{"\n"}<_components.p>{"따라서 NestLogged에서는 NestJS의 커스텀 로거를 적용하는 방식을 따라 새로운 ConsoleLogger를 만들었습니다."}</_components.p>{"\n"}<_components.p>{"적용하는 방식은 다음과 같습니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"main.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ConsoleLogger } from 'nestlogged';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule, {\n    logger: new ConsoleLogger(),\n  });\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.p>{"이 ConsoleLogger는 NestJS의 방식을 그대로 가져와 추가된 Request ID와 Scope에 대한 처리 코드만 추가한 클래스입니다."}</_components.p>{"\n"}<_components.p>{"이 문서의 아래에서는 pino와 같은 서드파티 로깅 패키지를 NestLogged 패키지와 함께 쓰는 방법도 설명합니다."}</_components.p>{"\n"}<_components.blockquote>{"\n"}<_components.p>{"[!info] NestJS에서 로거를 확장하는 방법에 대해 더 자세히 알아보려면 다음 링크를 확인해보세요.\n"}<_components.a href="https://docs.nestjs.com/techniques/logger#extend-built-in-logger">{"Documentation | NestJS - A progressive Node.js framework"}</_components.a></_components.p>{"\n"}</_components.blockquote>{"\n"}<_components.hr />{"\n"}<_components.h1 id="메서드에-로그-붙이기">{"메서드에 로그 붙이기"}</_components.h1>{"\n"}<_components.p>{"NestLogged에서 가장 기초이자 기반은 메서드에 호출 / 종료 / 오류 로그를 붙이는 것입니다."}</_components.p>{"\n"}<_components.p>{"이 역할을 담당하는 기본적인 데코레이터는 "}<_components.code>{"@LoggedFunction()"}</_components.code>{" 과 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 입니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li><_components.code>{"@LoggedFunction()"}</_components.code>{" - Service 등 일반적인 메서드에 사용됩니다."}</_components.li>{"\n"}<_components.li><_components.code>{"@LoggedRoute()"}</_components.code>{" - Controller의 메서드에 사용됩니다. "}<_components.code>{"@LoggedFunction()"}</_components.code>{" 에 더해 추가로 엔드포인트의 path와 method를 수집합니다."}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.controller.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { Controller, Get } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { LoggedRoute } from 'nestlogged';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @LoggedRoute()\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.service.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { Injectable } from '@nestjs/common';\nimport { LoggedFunction } from 'nestlogged';\n\n@Injectable()\nexport class AppService {\n  @LoggedFunction()\n  getHello(): string {\n    return 'Hello!';\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"로그 출력"}</_components.div><_components.div className="remark-code-meta__lang">{"Log"}</_components.div></_components.div><_components.pre><_components.code className="language-log" data-language="log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\nLOG [AppService] HIT FUNCTION AppService.getHello\nLOG [AppService] RETURNED FUNCTION AppService.getHello\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.blockquote>{"\n"}<_components.p>{"[!warning] "}<_components.code>{"@LoggedRoute()"}</_components.code>{"를 사용할 때는 데코레이터의 순서에 주의해야 합니다.\n항상 "}<_components.code>{"@LoggedRoute()"}</_components.code>{"가 "}<_components.code>{"@Get()"}</_components.code>{", "}<_components.code>{"@Post()"}</_components.code>{" 등의 데코레이터보다 "}<_components.strong>{"먼저 오도록 배치"}</_components.strong>{"하세요."}</_components.p>{"\n"}<_components.p><_components.code>{"@Get()"}</_components.code>{"과 "}<_components.code>{"@Post()"}</_components.code>{"와 같은 HTTP 메서드 데코레이터는 적용되는 메서드에 path와 method를 메타데이터로 추가합니다. "}<_components.code>{"@LoggedRoute()"}</_components.code>{"는 이 메타데이터를 읽어오는 작업을 수행하는데, HTTP 메서드 데코레이터보다 먼저 수행될 경우 읽어올 메타데이터가 없어 undefined로 표시됩니다."}</_components.p>{"\n"}<_components.p>{"순서가 헷갈린다면, 데코레이터가 "}<_components.code>{"LoggedRoute(Get(getHello))"}</_components.code>{"와 같이 작동한다는 것을 기억하세요."}</_components.p>{"\n"}</_components.blockquote>{"\n"}<_components.h2 id="데코레이터-옵션">{"데코레이터 옵션"}</_components.h2>{"\n"}<_components.p><_components.code>{"@LoggedRoute()"}</_components.code>{"와 "}<_components.code>{"@LoggedFunction()"}</_components.code>{"을 설정하기 위해서 옵션을 줄 수 있습니다."}</_components.p>{"\n"}<_components.p>{"두 데코레이터 모두 동일한 타입의 옵션을 받으며, 옵션의 형태와 기본값은 다음과 같습니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"옵션의 타입 정의 (src/logged/utils.ts)"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"export interface OverrideBuildOptions {\n  callLogLevel: LogLevel | 'skip';\n  returnLogLevel: LogLevel | 'skip';\n  errorLogLevel: LogLevel | 'skip';\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"옵션 기본값 (src/logged/utils.ts)"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"export const defaultOverrideBuildOptions: OverrideBuildOptions = {\n  callLogLevel: 'log',\n  returnLogLevel: 'log',\n  errorLogLevel: 'error',\n};\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.h2 id="전체-메서드-일괄-로깅">{"전체 메서드 일괄 로깅"}</_components.h2>{"\n"}<_components.p>{"클래스 내의 모든 메서드에 일일히 데코레이터를 붙이는 것은 매우 번거로운 일이 될 것이 분명하므로, 그러한 형태를 피하기 위해 클래스에 적용했을 때 클래스 내의 모든 메서드에 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 또는 "}<_components.code>{"@LoggedFunction()"}</_components.code>{"을 적용하는 클래스 데코레이터를 제공합니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li><_components.code>{"@LoggedController()"}</_components.code>{" - 클래스에 NestJS의 "}<_components.code>{"@Controller()"}</_components.code>{" 데코레이터를 적용시키고, 모든 메서드에 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 데코레이터를 일괄 적용시킵니다."}</_components.li>{"\n"}<_components.li><_components.code>{"@LoggedInjectable()"}</_components.code>{" - 클래스에 NestJS의 "}<_components.code>{"@Injectable()"}</_components.code>{" 데코레이터를 적용시키고, 모든 메서드에 "}<_components.code>{"@LoggedFunction()"}</_components.code>{" 데코레이터를 일괄 적용시킵니다."}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.controller.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { Get } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { LoggedController } from 'nestlogged';\n\n@LoggedController()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.service.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { LoggedInjectable } from 'nestlogged';\n\n@LoggedInjectable()\nexport class AppService {\n  getHello(): string {\n    return 'Hello!';\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.p>{"메서드를 일괄 로깅해주는 클래스 데코레이터를 사용하면 쓸데없는 코드의 반복을 줄이고, 또한 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 데코레이터의 위치에 대해 고민할 필요가 없어집니다."}</_components.p>{"\n"}<_components.hr />{"\n"}<_components.h1 id="호출-파라미터-로그">{"호출 파라미터 로그"}</_components.h1>{"\n"}<_components.p>{"호출 시의 파라미터를 로그에 포함하기 위해서는 "}<_components.code>{"@Logged()"}</_components.code>{" 데코레이터를 사용해야 합니다."}</_components.p>{"\n"}<_components.p>{"로그에 포함하기를 원하는 파라미터의 앞에 "}<_components.code>{"@Logged()"}</_components.code>{" 를 붙여 적용시킬 수 있습니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.service.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"@LoggedInjectable()\nexport class AppService {\n  getMessage(@Logged('message') message: string): string {\n    return message;\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"출력 로그"}</_components.div><_components.div className="remark-code-meta__lang">{"Log"}</_components.div></_components.div><_components.pre><_components.code className="language-log" data-language="log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\nLOG [AppService] HIT FUNCTION AppService.getMessage WITH message=Hello!\nLOG [AppService] RETURNED FUNCTION AppService.getMessage\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.p>{"데코레이터의 첫 번째 파라미터는 기록될 파라미터의 이름을 결정합니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.service.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"@LoggedInjectable()\nexport class AppService {\n  getMessage(@Logged('otherName') message: string): string {\n    return message;\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"출력 로그"}</_components.div><_components.div className="remark-code-meta__lang">{"Log"}</_components.div></_components.div><_components.pre><_components.code className="language-log" data-language="log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\nLOG [AppService] HIT FUNCTION AppService.getMessage WITH otherName=Hello!\nLOG [AppService] RETURNED FUNCTION AppService.getMessage\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.h2 id="데코레이터-파라미터">{"데코레이터 파라미터"}</_components.h2>{"\n"}<_components.h3 id="name-필수">{"name (필수)"}</_components.h3>{"\n"}<_components.p>{"TypeScript에서는 파라미터에 데코레이터를 적용시킬 때 데코레이터에 대한 파라미터의 정보를 넘겨줍니다.\n이 때, 넘어가는 정보들 중 파라미터의 이름에 대한 부분은 "}<_components.strong>{"존재하지 않습니다."}</_components.strong></_components.p>{"\n"}<_components.p>{"따라서, 데코레이터는 어떤 방식으로든 적용되는 파라미터의 이름을 "}<_components.strong>{"알 수 없고"}</_components.strong>{", 때문에 사용자가 직접 이름을 넘겨줘야 합니다."}</_components.p>{"\n"}<_components.h3 id="options-선택">{"Options (선택)"}</_components.h3>{"\n"}<_components.p><_components.code>{"@Logged()"}</_components.code>{" 데코레이터가 붙은 파라미터의 값이 object일 경우, 로그 시 "}<_components.code>{"[object Object]"}</_components.code>{"와 같이 출력되는 것을 방지하기 위해 내부적으로 JSON.stringify를 사용해 처리하고 있습니다."}</_components.p>{"\n"}<_components.p>{"그러나, object 안에 로그에 "}<_components.strong>{"포함하고 싶지 않은 정보"}</_components.strong>{"가 있다면 이를 제거하고 출력하기 위해, 또는 "}<_components.strong>{"원하는 정보만 간추려서"}</_components.strong>{" 출력하기 위해 options의 "}<_components.code>{"includePath"}</_components.code>{"와 "}<_components.code>{"excludePath"}</_components.code>{"를 사용합니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"Logged의 options 정의"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"type Path = string;\ntype Paths = Path[];\n\ninterface IncludeExcludePath {\n    includePath?: Paths;\n    excludePath?: Paths;\n}\n\nexport function Logged (name: string, options?: IncludeExcludePath): ParameterDecoratorType;\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.controller.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { Get } from '@nestjs/common';\nimport { AppService, UserData } from './app.service';\nimport { LoggedController } from 'nestlogged';\n\n@LoggedController()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  createNewUser(): UserData {\n    return this.appService.createNewUser({\n      displayName: 'John Doe',\n      email: 'john.doe@example.com',\n      auth: {\n        loginName: 'john.doe',\n        password: 'password',\n      },\n    });\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"콘솔 출력"}</_components.div><_components.div className="remark-code-meta__lang">{"Log"}</_components.div></_components.div><_components.pre><_components.code className="language-log" data-language="log">{"LOG [AppController] HIT ENDPOINT AppController.createNewUser (AppController::/[GET])\nLOG [AppService] HIT FUNCTION AppService.createNewUser WITH user={\"displayName\":\"John Doe\",\"email\":\"john.doe@example.com\",\"auth\":{\"loginName\":\"john.doe\"}}\nLOG [AppService] RETURNED FUNCTION AppService.createNewUser\nLOG [AppController] RETURNED ENDPOINT AppController.createNewUser (AppController::/[GET])\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.h2 id="each-사용법">{"Each 사용법"}</_components.h2>{"\n"}<_components.p><_components.code>{"@Logged()"}</_components.code>{" 데코레이터의 "}<_components.code>{"name"}</_components.code>{" 파라미터 위치에 "}<_components.code>{"object"}</_components.code>{"를 줄 경우 "}<_components.code>{"each"}</_components.code>{" 파라미터로 간주됩니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"Logged의 Each 파라미터 오버로드"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"export type Path = string;\nexport type Each = Record<string, Path>;\n\nexport function Logged(name: string, options?: IncludeExcludePath): ParameterDecoratorType;\nexport function Logged(name: Each): ParameterDecoratorType;\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.p>{"Each를 사용할 경우, "}<_components.strong>{"하나의 파라미터를 여러개로 분할해"}</_components.strong>{" 로그에 표시할 수 있습니다."}</_components.p>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.service.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { Logged, LoggedInjectable, Returns } from 'nestlogged';\n\nexport interface UserData {\n  displayName: string;\n  email: string;\n  auth: {\n    loginName: string;\n    password: string;\n  };\n}\n\n@LoggedInjectable()\nexport class AppService {\n  @Returns()\n  createNewUser(\n    @Logged({\n      displayName: 'displayName',\n      email: 'email',\n      loginName: 'auth.loginName',\n    })\n    newUserData: UserData,\n  ) {\n    // create new user\n    return newUserData;\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"출력 로그"}</_components.div><_components.div className="remark-code-meta__lang">{"Log"}</_components.div></_components.div><_components.pre><_components.code className="language-log" data-language="log">{"[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppController] HIT ENDPOINT AppController.createNewUser (AppController::/[GET])\n[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppService] HIT FUNCTION AppService.createNewUser WITH displayName=John Doe, email=john.doe@example.com, loginName=john.doe\n[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppService] RETURNED FUNCTION AppService.createNewUser WITH {\"displayName\":\"John Doe\",\"email\":\"john.doe@example.com\",\"auth\":{\"loginName\":\"john.doe\",\"password\":\"password\"}}\n[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppController] RETURNED ENDPOINT AppController.createNewUser (AppController::/[GET])\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.hr />{"\n"}<_components.h1 id="종료-반환값-로그">{"종료 반환값 로그"}</_components.h1>{"\n"}<_components.p><_components.code>{"@Returns()"}</_components.code>{" 데코레이터를 사용하면 메서드의 반환값을 로그에 포함할 수 있습니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li>{"아무런 파라미터 없이 사용할 경우 반환값을 전부 출력합니다."}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"app.service.ts"}</_components.div><_components.div className="remark-code-meta__lang">{"TypeScript"}</_components.div></_components.div><_components.pre><_components.code className="language-ts" data-language="ts">{"import { LoggedInjectable, Returns } from 'nestlogged';\n\n@LoggedInjectable()\nexport class AppService {\n  @Returns()\n  getHello(): string {\n    return 'Hello World!';\n  }\n}\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.div className="remark-code-meta-wrapper"><_components.div className="remark-code-meta-block"><_components.div className="remark-code-meta__filename">{"출력 로그"}</_components.div><_components.div className="remark-code-meta__lang">{"Log"}</_components.div></_components.div><_components.pre><_components.code className="language-log" data-language="log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\nLOG [AppService] HIT FUNCTION AppService.getHello\nLOG [AppService] RETURNED FUNCTION AppService.getHello WITH Hello World!\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre></_components.div>{"\n"}<_components.hr />{"\n"}<_components.h1 id="기타-특수함수-로그">{"기타 특수함수 로그"}</_components.h1>{"\n"}<_components.hr />{"\n"}<_components.h1 id="로그-주입과-범위-로깅">{"로그 주입과 범위 로깅"}</_components.h1>{"\n"}<_components.hr />{"\n"}<_components.h1 id="추가-pino-적용하기">{"추가: Pino 적용하기"}</_components.h1></>;
}
export default function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = props.components || ({});
  return MDXLayout ? <MDXLayout {...props}><_createMdxContent {...props} /></MDXLayout> : _createMdxContent(props);
}
