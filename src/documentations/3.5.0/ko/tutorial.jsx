/*@jsxRuntime automatic*/
/*@jsxImportSource react*/
function _createMdxContent(props) {
  const _components = {
    a: "a",
    blockquote: "blockquote",
    code: "code",
    h1: "h1",
    h2: "h2",
    h3: "h3",
    hr: "hr",
    li: "li",
    p: "p",
    pre: "pre",
    strong: "strong",
    ul: "ul",
    ...props.components
  };
  return <><_components.p>{"이 문서에서는 NestLogged에 대해 아무것도 모른다는 전제 하에 처음부터 끝까지 NestLogged의 모든 "}<_components.strong>{"기능 사용법"}</_components.strong>{"을 설명합니다."}</_components.p>{"\n"}<_components.p>{"NestLogged를 처음 접하는 분에게 추천합니다."}</_components.p>{"\n"}<_components.h1>{"NestLogged에 대하여"}</_components.h1>{"\n"}<_components.p>{"NestLogged는 NestJS를 위한 간단한 데코레이터를 제공하며, 여러 복잡한 로깅을 간단하게 적용할 수 있도록 도와줍니다."}</_components.p>{"\n"}<_components.p>{"NestLogged가 제공하는 기능은 다음과 같습니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li>{"함수의 호출과 종료, 오류 로그 ("}<_components.strong>{"NestLogged의 핵심이자 기반입니다!"}</_components.strong>{")"}</_components.li>{"\n"}<_components.li>{"함수의 호출 시 파라미터 로그"}{"\n"}<_components.ul>{"\n"}<_components.li>{"파라미터가 object 또는 array일 경우 일부 프로퍼티의 숨김 또는 선택 지원"}</_components.li>{"\n"}</_components.ul>{"\n"}</_components.li>{"\n"}<_components.li>{"함수의 종료 시 반환값 로그"}</_components.li>{"\n"}<_components.li>{"함수의 호출 흐름을 따라 trace log 표시 (Scope라고 부릅니다)"}</_components.li>{"\n"}<_components.li>{"고유한 Request에 대한 ID 표시"}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.p>{"예시 로그 출력을 보여드리겠습니다:"}</_components.p>{"\n"}<_components.pre><_components.code className="language-log">{"LOG [AppMiddleware] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppMiddleware.AppMiddleware: HIT MIDDLEWARE AppMiddleware.AppMiddleware (/)\r\nLOG [AppMiddleware] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppMiddleware.AppMiddleware: Hello from Middleware!\r\nLOG [AppGuard] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppGuard.AppGuard: HIT GUARD AppGuard.AppGuard (/)\r\nLOG [AppGuard] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppGuard.AppGuard: Hello from Guard!\r\nLOG [AppGuard] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppGuard.AppGuard: RETURNED GUARD AppGuard.AppGuard (/)\r\nLOG [AppMiddleware] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppMiddleware.AppMiddleware: RETURNED MIDDLEWARE AppMiddleware.AppMiddleware (/)\r\nLOG [AppController] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello: HIT ENDPOINT AppController.getHello (AppController::/[GET])\r\nLOG [AppService] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello -> AppService.getHello: HIT FUNCTION AppService.getHello WITH value=i\r\nLOG [AppService] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello -> AppService.getHello: Hello from AppService!\r\nLOG [AppService] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello -> AppService.getHello: RETURNED FUNCTION AppService.getHello\r\nLOG [AppController] ID=[nPcz74xbRvm2IB0rTR6B2g/0000000001] | AppController.getHello: RETURNED ENDPOINT AppController.getHello (AppController::/[GET]) WITH i\n"}</_components.code></_components.pre>{"\n"}<_components.p>{"재미있는 점은 이 로그들이 간단한 데코레이터 몇 개로 이루어질 수 있는 것이라는 점입니다.\r\n지금부터 하나씩 어떻게 하는지 알려드리겠습니다."}</_components.p>{"\n"}<_components.hr />{"\n"}<_components.h1>{"NestLogged 로거 적용"}</_components.h1>{"\n"}<_components.p>{"NestLogged에서는 내부에서 처리되는 로그 객체에 Request ID와 Scope를 추가합니다."}</_components.p>{"\n"}<_components.p>{"그러나 NestJS에서 기본으로 적용되어 있는 ConsoleLogger는 추가된 Request ID와 Scope를 제대로 포맷하지 않고 출력하기 때문에 새로운 ConsoleLogger의 적용이 필요합니다."}</_components.p>{"\n"}<_components.p>{"따라서 NestLogged에서는 NestJS의 커스텀 로거를 적용하는 방식을 따라 새로운 ConsoleLogger를 만들었습니다."}</_components.p>{"\n"}<_components.p>{"적용하는 방식은 다음과 같습니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"import { NestFactory } from '@nestjs/core';\r\nimport { AppModule } from './app.module';\r\nimport { ConsoleLogger } from 'nestlogged';\r\n\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule, {\r\n    logger: new ConsoleLogger(),\r\n  });\r\n  await app.listen(process.env.PORT ?? 3000);\r\n}\r\nbootstrap();\n"}</_components.code></_components.pre>{"\n"}<_components.p>{"이 ConsoleLogger는 NestJS의 방식을 그대로 가져와 추가된 Request ID와 Scope에 대한 처리 코드만 추가한 클래스입니다."}</_components.p>{"\n"}<_components.p>{"이 문서의 아래에서는 pino와 같은 서드파티 로깅 패키지를 NestLogged 패키지와 함께 쓰는 방법도 설명합니다."}</_components.p>{"\n"}<_components.blockquote>{"\n"}<_components.p>{"[!info] NestJS에서 로거를 확장하는 방법에 대해 더 자세히 알아보려면 다음 링크를 확인해보세요.\r\n"}<_components.a href="https://docs.nestjs.com/techniques/logger#extend-built-in-logger">{"Documentation | NestJS - A progressive Node.js framework"}</_components.a></_components.p>{"\n"}</_components.blockquote>{"\n"}<_components.hr />{"\n"}<_components.h1>{"메서드에 로그 붙이기"}</_components.h1>{"\n"}<_components.p>{"NestLogged에서 가장 기초이자 기반은 메서드에 호출 / 종료 / 오류 로그를 붙이는 것입니다."}</_components.p>{"\n"}<_components.p>{"이 역할을 담당하는 기본적인 데코레이터는 "}<_components.code>{"@LoggedFunction()"}</_components.code>{" 과 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 입니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li><_components.code>{"@LoggedFunction()"}</_components.code>{" - Service 등 일반적인 메서드에 사용됩니다."}</_components.li>{"\n"}<_components.li><_components.code>{"@LoggedRoute()"}</_components.code>{" - Controller의 메서드에 사용됩니다. "}<_components.code>{"@LoggedFunction()"}</_components.code>{" 에 더해 추가로 엔드포인트의 path와 method를 수집합니다."}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.pre><_components.code className="language-ts">{"import { Controller, Get } from '@nestjs/common';\r\nimport { AppService } from './app.service';\r\nimport { LoggedRoute } from 'nestlogged';\r\n\r\n@Controller()\r\nexport class AppController {\r\n  constructor(private readonly appService: AppService) {}\r\n\r\n  @LoggedRoute()\r\n  @Get()\r\n  getHello(): string {\r\n    return this.appService.getHello();\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-ts">{"import { Injectable } from '@nestjs/common';\r\nimport { LoggedFunction } from 'nestlogged';\r\n\r\n@Injectable()\r\nexport class AppService {\r\n  @LoggedFunction()\r\n  getHello(): string {\r\n    return 'Hello!';\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\r\nLOG [AppService] HIT FUNCTION AppService.getHello\r\nLOG [AppService] RETURNED FUNCTION AppService.getHello\r\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre>{"\n"}<_components.blockquote>{"\n"}<_components.p>{"[!warning] "}<_components.code>{"@LoggedRoute()"}</_components.code>{"를 사용할 때는 데코레이터의 순서에 주의해야 합니다.\r\n항상 "}<_components.code>{"@LoggedRoute()"}</_components.code>{"가 "}<_components.code>{"@Get()"}</_components.code>{", "}<_components.code>{"@Post()"}</_components.code>{" 등의 데코레이터보다 "}<_components.strong>{"먼저 오도록 배치"}</_components.strong>{"하세요."}</_components.p>{"\n"}<_components.p><_components.code>{"@Get()"}</_components.code>{"과 "}<_components.code>{"@Post()"}</_components.code>{"와 같은 HTTP 메서드 데코레이터는 적용되는 메서드에 path와 method를 메타데이터로 추가합니다. "}<_components.code>{"@LoggedRoute()"}</_components.code>{"는 이 메타데이터를 읽어오는 작업을 수행하는데, HTTP 메서드 데코레이터보다 먼저 수행될 경우 읽어올 메타데이터가 없어 undefined로 표시됩니다."}</_components.p>{"\n"}<_components.p>{"순서가 헷갈린다면, 데코레이터가 "}<_components.code>{"LoggedRoute(Get(getHello))"}</_components.code>{"와 같이 작동한다는 것을 기억하세요."}</_components.p>{"\n"}</_components.blockquote>{"\n"}<_components.h2>{"데코레이터 옵션"}</_components.h2>{"\n"}<_components.p><_components.code>{"@LoggedRoute()"}</_components.code>{"와 "}<_components.code>{"@LoggedFunction()"}</_components.code>{"을 설정하기 위해서 옵션을 줄 수 있습니다."}</_components.p>{"\n"}<_components.p>{"두 데코레이터 모두 동일한 타입의 옵션을 받으며, 옵션의 형태와 기본값은 다음과 같습니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"export interface OverrideBuildOptions {\r\n  callLogLevel: LogLevel | 'skip';\r\n  returnLogLevel: LogLevel | 'skip';\r\n  errorLogLevel: LogLevel | 'skip';\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-ts">{"export const defaultOverrideBuildOptions: OverrideBuildOptions = {\r\n  callLogLevel: 'log',\r\n  returnLogLevel: 'log',\r\n  errorLogLevel: 'error',\r\n};\n"}</_components.code></_components.pre>{"\n"}<_components.h2>{"전체 메서드 일괄 로깅"}</_components.h2>{"\n"}<_components.p>{"클래스 내의 모든 메서드에 일일히 데코레이터를 붙이는 것은 매우 번거로운 일이 될 것이 분명하므로, 그러한 형태를 피하기 위해 클래스에 적용했을 때 클래스 내의 모든 메서드에 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 또는 "}<_components.code>{"@LoggedFunction()"}</_components.code>{"을 적용하는 클래스 데코레이터를 제공합니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li><_components.code>{"@LoggedController()"}</_components.code>{" - 클래스에 NestJS의 "}<_components.code>{"@Controller()"}</_components.code>{" 데코레이터를 적용시키고, 모든 메서드에 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 데코레이터를 일괄 적용시킵니다."}</_components.li>{"\n"}<_components.li><_components.code>{"@LoggedInjectable()"}</_components.code>{" - 클래스에 NestJS의 "}<_components.code>{"@Injectable()"}</_components.code>{" 데코레이터를 적용시키고, 모든 메서드에 "}<_components.code>{"@LoggedFunction()"}</_components.code>{" 데코레이터를 일괄 적용시킵니다."}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.pre><_components.code className="language-ts">{"import { Get } from '@nestjs/common';\r\nimport { AppService } from './app.service';\r\nimport { LoggedController } from 'nestlogged';\r\n\r\n@LoggedController()\r\nexport class AppController {\r\n  constructor(private readonly appService: AppService) {}\r\n\r\n  @Get()\r\n  getHello(): string {\r\n    return this.appService.getHello();\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-ts">{"import { LoggedInjectable } from 'nestlogged';\r\n\r\n@LoggedInjectable()\r\nexport class AppService {\r\n  getHello(): string {\r\n    return 'Hello!';\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.p>{"메서드를 일괄 로깅해주는 클래스 데코레이터를 사용하면 쓸데없는 코드의 반복을 줄이고, 또한 "}<_components.code>{"@LoggedRoute()"}</_components.code>{" 데코레이터의 위치에 대해 고민할 필요가 없어집니다."}</_components.p>{"\n"}<_components.hr />{"\n"}<_components.h1>{"호출 파라미터 로그"}</_components.h1>{"\n"}<_components.p>{"호출 시의 파라미터를 로그에 포함하기 위해서는 "}<_components.code>{"@Logged()"}</_components.code>{" 데코레이터를 사용해야 합니다."}</_components.p>{"\n"}<_components.p>{"로그에 포함하기를 원하는 파라미터의 앞에 "}<_components.code>{"@Logged()"}</_components.code>{" 를 붙여 적용시킬 수 있습니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"@LoggedInjectable()\r\nexport class AppService {\r\n  getMessage(@Logged('message') message: string): string {\r\n    return message;\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\r\nLOG [AppService] HIT FUNCTION AppService.getMessage WITH message=Hello!\r\nLOG [AppService] RETURNED FUNCTION AppService.getMessage\r\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre>{"\n"}<_components.p>{"데코레이터의 첫 번째 파라미터는 기록될 파라미터의 이름을 결정합니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"@LoggedInjectable()\r\nexport class AppService {\r\n  getMessage(@Logged('otherName') message: string): string {\r\n    return message;\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\r\nLOG [AppService] HIT FUNCTION AppService.getMessage WITH otherName=Hello!\r\nLOG [AppService] RETURNED FUNCTION AppService.getMessage\r\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre>{"\n"}<_components.h2>{"데코레이터 파라미터"}</_components.h2>{"\n"}<_components.h3>{"name (필수)"}</_components.h3>{"\n"}<_components.p>{"TypeScript에서는 파라미터에 데코레이터를 적용시킬 때 데코레이터에 대한 파라미터의 정보를 넘겨줍니다.\r\n이 때, 넘어가는 정보들 중 파라미터의 이름에 대한 부분은 "}<_components.strong>{"존재하지 않습니다."}</_components.strong></_components.p>{"\n"}<_components.p>{"따라서, 데코레이터는 어떤 방식으로든 적용되는 파라미터의 이름을 "}<_components.strong>{"알 수 없고"}</_components.strong>{", 때문에 사용자가 직접 이름을 넘겨줘야 합니다."}</_components.p>{"\n"}<_components.h3>{"Options (선택)"}</_components.h3>{"\n"}<_components.p><_components.code>{"@Logged()"}</_components.code>{" 데코레이터가 붙은 파라미터의 값이 object일 경우, 로그 시 "}<_components.code>{"[object Object]"}</_components.code>{"와 같이 출력되는 것을 방지하기 위해 내부적으로 JSON.stringify를 사용해 처리하고 있습니다."}</_components.p>{"\n"}<_components.p>{"그러나, object 안에 로그에 "}<_components.strong>{"포함하고 싶지 않은 정보"}</_components.strong>{"가 있다면 이를 제거하고 출력하기 위해, 또는 "}<_components.strong>{"원하는 정보만 간추려서"}</_components.strong>{" 출력하기 위해 options의 "}<_components.code>{"includePath"}</_components.code>{"와 "}<_components.code>{"excludePath"}</_components.code>{"를 사용합니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"type Path = string;\r\ntype Paths = Path[];\r\n\r\ninterface IncludeExcludePath {\r\n    includePath?: Paths;\r\n    excludePath?: Paths;\r\n}\r\n\r\nexport function Logged (name: string, options?: IncludeExcludePath): ParameterDecoratorType;\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-ts">{"import { Get } from '@nestjs/common';\r\nimport { AppService, UserData } from './app.service';\r\nimport { LoggedController } from 'nestlogged';\r\n\r\n@LoggedController()\r\nexport class AppController {\r\n  constructor(private readonly appService: AppService) {}\r\n\r\n  @Get()\r\n  createNewUser(): UserData {\r\n    return this.appService.createNewUser({\r\n      displayName: 'John Doe',\r\n      email: 'john.doe@example.com',\r\n      auth: {\r\n        loginName: 'john.doe',\r\n        password: 'password',\r\n      },\r\n    });\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-log">{"LOG [AppController] HIT ENDPOINT AppController.createNewUser (AppController::/[GET])\r\nLOG [AppService] HIT FUNCTION AppService.createNewUser WITH user={\"displayName\":\"John Doe\",\"email\":\"john.doe@example.com\",\"auth\":{\"loginName\":\"john.doe\"}}\r\nLOG [AppService] RETURNED FUNCTION AppService.createNewUser\r\nLOG [AppController] RETURNED ENDPOINT AppController.createNewUser (AppController::/[GET])\n"}</_components.code></_components.pre>{"\n"}<_components.h2>{"Each 사용법"}</_components.h2>{"\n"}<_components.p><_components.code>{"@Logged()"}</_components.code>{" 데코레이터의 "}<_components.code>{"name"}</_components.code>{" 파라미터 위치에 "}<_components.code>{"object"}</_components.code>{"를 줄 경우 "}<_components.code>{"each"}</_components.code>{" 파라미터로 간주됩니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"export type Path = string;\r\nexport type Each = Record<string, Path>;\r\n\r\nexport function Logged(name: string, options?: IncludeExcludePath): ParameterDecoratorType;\r\nexport function Logged(name: Each): ParameterDecoratorType;\n"}</_components.code></_components.pre>{"\n"}<_components.p>{"Each를 사용할 경우, "}<_components.strong>{"하나의 파라미터를 여러개로 분할해"}</_components.strong>{" 로그에 표시할 수 있습니다."}</_components.p>{"\n"}<_components.pre><_components.code className="language-ts">{"import { Logged, LoggedInjectable, Returns } from 'nestlogged';\r\n\r\nexport interface UserData {\r\n  displayName: string;\r\n  email: string;\r\n  auth: {\r\n    loginName: string;\r\n    password: string;\r\n  };\r\n}\r\n\r\n@LoggedInjectable()\r\nexport class AppService {\r\n  @Returns()\r\n  createNewUser(\r\n    @Logged({\r\n      displayName: 'displayName',\r\n      email: 'email',\r\n      loginName: 'auth.loginName',\r\n    })\r\n    newUserData: UserData,\r\n  ) {\r\n    // create new user\r\n    return newUserData;\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-log">{"[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppController] HIT ENDPOINT AppController.createNewUser (AppController::/[GET])\r\n[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppService] HIT FUNCTION AppService.createNewUser WITH displayName=John Doe, email=john.doe@example.com, loginName=john.doe\r\n[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppService] RETURNED FUNCTION AppService.createNewUser WITH {\"displayName\":\"John Doe\",\"email\":\"john.doe@example.com\",\"auth\":{\"loginName\":\"john.doe\",\"password\":\"password\"}}\r\n[Nest] 28896  - 05/14/2025, 2:18:27 AM     LOG [AppController] RETURNED ENDPOINT AppController.createNewUser (AppController::/[GET])\n"}</_components.code></_components.pre>{"\n"}<_components.hr />{"\n"}<_components.h1>{"종료 반환값 로그"}</_components.h1>{"\n"}<_components.p><_components.code>{"@Returns()"}</_components.code>{" 데코레이터를 사용하면 메서드의 반환값을 로그에 포함할 수 있습니다."}</_components.p>{"\n"}<_components.ul>{"\n"}<_components.li>{"아무런 파라미터 없이 사용할 경우 반환값을 전부 출력합니다."}</_components.li>{"\n"}</_components.ul>{"\n"}<_components.pre><_components.code className="language-ts">{"import { LoggedInjectable, Returns } from 'nestlogged';\r\n\r\n@LoggedInjectable()\r\nexport class AppService {\r\n  @Returns()\r\n  getHello(): string {\r\n    return 'Hello World!';\r\n  }\r\n}\n"}</_components.code></_components.pre>{"\n"}<_components.pre><_components.code className="language-log">{"LOG [AppController] HIT ENDPOINT AppController.getHello (AppController::/[GET])\r\nLOG [AppService] HIT FUNCTION AppService.getHello\r\nLOG [AppService] RETURNED FUNCTION AppService.getHello WITH Hello World!\r\nLOG [AppController] RETURNED ENDPOINT AppController.getHello (AppController::/[GET])\n"}</_components.code></_components.pre>{"\n"}<_components.hr />{"\n"}<_components.h1>{"기타 특수함수 로그"}</_components.h1>{"\n"}<_components.hr />{"\n"}<_components.h1>{"로그 주입과 범위 로깅"}</_components.h1>{"\n"}<_components.hr />{"\n"}<_components.h1>{"추가: Pino 적용하기"}</_components.h1></>;
}
export default function MDXContent(props = {}) {
  const {wrapper: MDXLayout} = props.components || ({});
  return MDXLayout ? <MDXLayout {...props}><_createMdxContent {...props} /></MDXLayout> : _createMdxContent(props);
}
